# FUNCTIONS
function aichat-session() {
  wezterm cli set-tab-title "/$1"
  aichat -s "$1"
}

function gps() {
  key=$(gpfzf)
  gopass show $key && gopass -c $key
}

function gpc() {
  gopass -c $(gpfzf)
}

function gpu() {
  gopass $(gpfzf) | grep user | sed -e 's/user://g' | tr -d '[:space:]' | xclip -selection c
}

function gpe() {
  gopass edit $(gpfzf)
}

# gopass w/ fzf
function gpfzf() {
  export pw=$(gopass ls -f | fzf --no-multi)
  echo "$pw"
}

# WezTerm tab management
# Current tab title only
function wti() {
  wezterm cli set-tab-title "$1"
}

# Triple-tab creation with naming pattern for multiple terms
function wta() {
  for term in "$@"; do
    local dir=$(pwd)  # Capture current directory
    # Rename current tab
    wezterm cli set-tab-title "#${term}"

    # Create tab 2 (~ suffix) with proper directory and title
    wezterm cli spawn --cwd "$dir" -- zsh -lic "echo -ne '\e]0;${term}>\a'; zsh"

    # Create tab 3 (> suffix) with proper directory and title
    wezterm cli spawn --cwd "$dir" -- zsh -lic "echo -ne '\e]0;${term}~\a'; zsh"

    # Create empty tab with default directory
    wezterm cli spawn -- zsh -l
  done
}

# tldr w/ fuzzy search
tldr-fzf() {
  selected=$(tldr --list | fzf \
    --query "$1" \
    --preview 'tldr {1} | bat --color=always --language=markdown --style=plain' \
    --preview-window=right:70% \
    --layout=reverse \
    --border \
    --height=80%)

  if [ -n "$selected" ]; then
      tldr "$selected" | bat --color=always --language=markdown --style=plain
  fi
}

# Add GitLab merge request fetch refspec
function glab-mr-fetch() {
  if ! git rev-parse --is-inside-work-tree &>/dev/null; then
    echo "Not a git repository"
    return 1
  fi

  local origin_url=$(git config --get remote.origin.url)
  if [[ -z "$origin_url" ]]; then
    echo "No remote 'origin' configured"
    return 1
  fi

  if [[ "$origin_url" != *"gitlab.com"* ]]; then
    echo "Remote origin is not a GitLab repository"
    return 0
  fi

  if git config --get-all remote.origin.fetch | grep -q 'refs/merge-requests/\*/head:refs/remotes/origin/mr/\*'; then
    echo "Merge request fetch refspec already exists"
    return 0
  fi

  git config --add remote.origin.fetch '+refs/merge-requests/*/head:refs/remotes/origin/mr/*'
  echo "Added merge request fetch refspec to origin remote"
}

# Rails migration timestamp
function rails_migration_date() {
  print -n $(date "+%Y%m%d%H%M%S")
}

# Kimi provider toggle
function kimi_enabled() {
  [ -f "/tmp/kimi_on" ]
}

# Helper: load project metadata
function _projects_source() {
  if [[ -f "$HOME/.projects" ]]; then
    source "$HOME/.projects"
    return 0
  else
    echo "~/.projects not found. Run bin/projects-setup to create a template." >&2
    return 1
  fi
}

# Helper: detect if secondary project is active
function project_secondary_enabled() {
  [ -f "/tmp/project_secondary_on" ]
}

# Helper: set ANTHROPIC_* envs for current provider and selected project
function _set_anthropic_env_for_selection() {
  _projects_source || return 1

  local project_prefix project_label
  if [[ -f "$HOME/dotfiles/zsh/lib/projects-env.zsh" ]]; then
    source "$HOME/dotfiles/zsh/lib/projects-env.zsh"
    if __projects_is_secondary; then
      project_prefix="SECONDARY"; project_label="secondary"
    else
      project_prefix="PRIMARY"; project_label="primary"
    fi
  else
    if project_secondary_enabled; then
      project_prefix="SECONDARY"; project_label="secondary"
    else
      project_prefix="PRIMARY"; project_label="primary"
    fi
  fi
  local code_var="${project_prefix}_PROJECT_CODE"
  local project_code="${(P)code_var}"

  if kimi_enabled; then
    # Use Moonshot (Kimi) for Anthropic-compatible API
    local key_var="${project_prefix}_PROJECT_MOONSHOT_AI_API_KEY"
    local moonshot_key="${(P)key_var}"
    export ANTHROPIC_AUTH_TOKEN="$moonshot_key"
    # For Goose in Kimi mode, also expose the key via ANTHROPIC_API_KEY
    export ANTHROPIC_API_KEY="$moonshot_key"
    export ANTHROPIC_BASE_URL=https://api.moonshot.ai/anthropic
    # Goose supports ANTHROPIC_HOST; point it to Kimi endpoint
    export ANTHROPIC_HOST=https://api.moonshot.ai/anthropic
    # Kimi latest model overrides
    export ANTHROPIC_MODEL=kimi-k2-0905-preview
    export ANTHROPIC_SMALL_FAST_MODEL=kimi-k2-0905-preview
    echo "Switched to Kimi mode for ${project_code} (${project_label} project)."
  else
    # Use direct Anthropic API
    unset ANTHROPIC_AUTH_TOKEN
    unset ANTHROPIC_BASE_URL
    # Reset Goose Anthropic host to default if previously set
    unset ANTHROPIC_HOST
    # Remove Kimi-specific model overrides
    unset ANTHROPIC_MODEL
    unset ANTHROPIC_SMALL_FAST_MODEL
    local key_var="${project_prefix}_PROJECT_ANTHROPIC_API_KEY"
    export ANTHROPIC_API_KEY="${(P)key_var}"
    echo "Switched to Anthropic mode for ${project_code} (${project_label} project)."
  fi
  _update_claude_settings_provider
}

# Helper: set Goose OpenAI API key for selected project
function _set_openai_env_for_selection() {
  # Prefer shared helper to avoid duplicated logic
  if [[ -f "$HOME/dotfiles/zsh/lib/projects-env.zsh" ]]; then
    source "$HOME/dotfiles/zsh/lib/projects-env.zsh"
    projects_apply_llm_env_from_selection
    return 0
  fi

  # Fallback: set provider API key from selected project's OPENAI key
  _projects_source || return 1
  local project_prefix project_label
  if project_secondary_enabled; then
    project_prefix="SECONDARY"; project_label="secondary"
  else
    project_prefix="PRIMARY"; project_label="primary"
  fi
  local key_var="${project_prefix}_PROJECT_OPENAI_API_KEY"
  local key_value="${(P)key_var}"
  export OPENAI_API_KEY="$key_value"
  echo "Set OpenAI key from ${project_label} project."
}

# Keep Claude Code settings.json in sync with provider mode
function _update_claude_settings_provider() {
  local settings_dir="$HOME/.claude"
  local settings_file="$settings_dir/settings.json"
  local helper_path='~/dotfiles/claude-code/bin/anthropic-api-key'
  mkdir -p "$settings_dir"

  if kimi_enabled; then
    if [[ -f "$settings_file" ]]; then
      if command -v jq >/dev/null 2>&1; then
        local tmp
        tmp=$(mktemp)
        jq 'del(.apiKeyHelper)' "$settings_file" > "$tmp" && mv "$tmp" "$settings_file"
      else
        sed -i.bak '/"apiKeyHelper"[[:space:]]*:/d' "$settings_file" || true
      fi
    fi
  else
    if command -v jq >/dev/null 2>&1 && [[ -f "$settings_file" ]]; then
      local tmp
      tmp=$(mktemp)
      jq --arg v "$helper_path" '.apiKeyHelper = $v' "$settings_file" > "$tmp" && mv "$tmp" "$settings_file"
    else
      printf '{\n  "apiKeyHelper": "%s"\n}\n' "$helper_path" > "$settings_file"
    fi
  fi
}

function kimi_set() {
  if [[ "$1" == "on" ]]; then
    touch /tmp/kimi_on
  else
    rm -f /tmp/kimi_on
  fi
  _set_anthropic_env_for_selection
}

function kimi_toggle() {
  if kimi_enabled; then
    kimi_set "off"
  else
    kimi_set "on"
  fi
}
alias kt=kimi_toggle

# Project selection toggle (primary <-> secondary)
function project_toggle() {
  if project_secondary_enabled; then
    rm -f /tmp/project_secondary_on
  else
    touch /tmp/project_secondary_on
  fi
  # Apply per-project LLM envs and Goose key via shared helper
  if [[ -f "$HOME/dotfiles/zsh/lib/projects-env.zsh" ]]; then
    source "$HOME/dotfiles/zsh/lib/projects-env.zsh"
    projects_apply_llm_env_from_selection
  fi
  # Apply per-project Goose defaults (provider/model) if present in ~/.projects
  if [[ -f "$HOME/.projects" ]]; then
    source "$HOME/.projects"
    local project_prefix
    if project_secondary_enabled; then
      project_prefix="SECONDARY"
    else
      project_prefix="PRIMARY"
    fi
    local prov_var="${project_prefix}_PROJECT_GOOSE_PROVIDER"
    local model_var="${project_prefix}_PROJECT_GOOSE_MODEL"
    local prov_val="${(P)prov_var}"
    local model_val="${(P)model_var}"
    if [[ -n "$prov_val" ]]; then export GOOSE_PROVIDER="$prov_val"; fi
    if [[ -n "$model_val" ]]; then export GOOSE_MODEL="$model_val"; fi
  fi
  # Then apply Anthropic/Kimi provider specifics and Claude settings sync
  _set_anthropic_env_for_selection
}
alias pt=project_toggle

# Wrap the claude CLI so that in Kimi mode we avoid leaking the Moonshot key as ANTHROPIC_API_KEY.
# Only define the wrapper if a real external "claude" binary exists on PATH.
typeset -g __CLAUDE_BIN
__CLAUDE_BIN=$(whence -p claude 2>/dev/null || true)
if [[ -n "$__CLAUDE_BIN" && -x "$__CLAUDE_BIN" ]]; then
  function claude() {
    if kimi_enabled; then
      ANTHROPIC_API_KEY= "$__CLAUDE_BIN" "$@"
    else
      "$__CLAUDE_BIN" "$@"
    fi
  }
fi

# vim: set ft=zsh:
