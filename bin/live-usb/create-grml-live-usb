#!/usr/bin/env ruby
# frozen_string_literal: true

require 'json'
require 'net/http'
require 'open3'
require 'digest'
require 'fileutils'
require 'optparse'
require 'tmpdir'
require 'uri'

module LiveUsb
  class Error < StandardError; end

  class BlockDevice
    attr_reader :raw

    def initialize(raw)
      @raw = raw
    end

    def name
      value('name')
    end

    def path
      value('path') || "/dev/#{name}"
    end

    def size
      value('size')
    end

    def model
      value('model') || value('vendor') || 'unknown'
    end

    def serial
      value('serial')
    end

    def type
      value('type')
    end

    def disk?
      type == 'disk'
    end

    def partition?
      type == 'part'
    end

    def usb?
      value('tran') == 'usb'
    end

    def removable?
      value('rm').to_i == 1 || value('hotplug').to_i == 1
    end

    def probable_usb?
      usb? || removable?
    end

    def partitions
      @partitions ||= children.select(&:partition?)
    end

    def filesystem
      value('fstype')
    end

    def mountpoints
      points = []
      mp = value('mountpoint')
      points << mp if present_mount?(mp)
      list = raw['mountpoints'] || raw['MOUNTPOINTS']
      if list.is_a?(Array)
        list.each do |entry|
          points << entry if present_mount?(entry)
        end
      end
      points.uniq
    end

    def mounted?
      !mountpoints.empty?
    end

    def description
      pieces = [path, size, model]
      pieces << "serial=#{serial}" if serial && !serial.empty?
      pieces.join(' | ')
    end

    private

    def children
      Array(raw['children']).map { |child| BlockDevice.new(child) }
    end

    def value(key)
      raw[key] || raw[key&.upcase]
    end

    def present_mount?(value)
      value && !value.empty? && value != '[SWAP]'
    end
  end

  class Creator
    DOWNLOAD_BASE = 'https://download.grml.org/'.freeze
    SHA256_FILE = 'SHA256SUMS'.freeze
    SIG_FILE = 'SHA256SUMS.asc'.freeze
    GRML_KEY_URL = 'https://download.grml.org/gnupg-michael-prokop.txt'.freeze
    DEFAULT_VARIANT = 'grml-full'.freeze
    DEFAULT_ARCH = 'amd64'.freeze
    DD_ARGS = %w[bs=4M status=progress conv=fsync].freeze
    CRITICAL_MOUNTPOINTS = %w[/ /boot /boot/efi /home /var /usr /etc].freeze
    SENSITIVE_FILESYSTEMS = %w[crypto_luks luks luks2 crypt lvm2_member swap].freeze
    MIN_FREE_BYTES = 2 * 1024 * 1024 * 1024 # 2 GiB
    CONNECT_TIMEOUT = 30
    DOWNLOAD_TIMEOUT = 900
    VARIANT_REGEX = /\A[a-z0-9][a-z0-9._-]+\z/i

    def self.validate_variant!(variant)
      return if variant.nil?
      return if VARIANT_REGEX.match?(variant)

      raise Error, 'Variant may only contain letters, numbers, dots, dashes, and underscores.'
    end

    def initialize(options = {})
      self.class.validate_variant!(options[:variant]) if options[:variant]
      @options = { variant: DEFAULT_VARIANT, arch: DEFAULT_ARCH, force: false, import_grml_key: false }.merge(options)
      @tmpdir = Dir.mktmpdir('grml-live-usb-')
      @use_sudo = !Process.euid.zero?
      @child_pid = nil
    end

    def run
      install_signal_handlers
      ensure_tmp_space!
      import_grml_key if options[:import_grml_key]
      device = resolve_device
      ensure_not_system_disk(device)
      @device_signature = capture_device_signature(device)
      iso_metadata = fetch_latest_iso
      iso_path = download_iso(iso_metadata)
      verify_checksum(iso_path, iso_metadata[:sha256])

      # Build combined boot parameters
      combined_params = []
      combined_params << options[:boot_params] if options[:boot_params] && !options[:boot_params].empty?

      if options[:enable_ssh]
        combined_params << "ssh=#{options[:ssh_password]}"
        puts "\nüîê SSH will be enabled with:"
        puts "   Username: grml"
        puts "   Password: #{options[:ssh_password]}"
      end

      # Add console font setting if TER16x32 is in boot params
      if options[:boot_params]&.include?('TER16x32')
        combined_params << "consolefont=ter-v32n"
      end

      # Add WiFi auto-enable if requested
      if options[:enable_wifi]
        combined_params << "scripts=wifi-enable"
      end

      # Customize ISO if any parameters specified
      if combined_params.any?
        options[:boot_params] = combined_params.join(' ')
        iso_path = customize_iso(iso_path, iso_metadata)
      end

      ensure_device_unmounted(device)
      ensure_signature_unchanged!(device)
      final_confirmation(device, iso_metadata)
      flash_image(iso_path, device)
      verify_written_image(iso_path, device)
      puts "\n‚úÖ Finished writing #{iso_metadata[:filename]} to #{device.path}."
    rescue Error => e
      warn "Error: #{e.message}"
      exit 1
    ensure
      cleanup_tmpdir
      restore_signal_handlers
    end

    private

    attr_reader :options

    def install_signal_handlers
      @previous_handlers = {}
      %w[INT TERM].each do |sig|
        @previous_handlers[sig] = Signal.trap(sig) { handle_signal(sig) }
      end
    end

    def restore_signal_handlers
      return unless @previous_handlers

      @previous_handlers.each do |sig, handler|
        Signal.trap(sig, handler)
      end
    end

    def handle_signal(signal)
      warn "\nReceived #{signal}, stopping..."
      Process.kill(signal, @child_pid) if @child_pid
      cleanup_tmpdir
      exit 130
    end

    def ensure_tmp_space!
      stats = filesystem_stats(@tmpdir)
      available = stats[:available_bytes]
      return if available.nil? || available >= MIN_FREE_BYTES

      raise Error, format('Need at least %<need>d bytes free in %<dir>s, only %<have>d available.', need: MIN_FREE_BYTES, dir: @tmpdir, have: available)
    end

    def filesystem_stats(path)
      stdout, status = Open3.capture2('df', '-B1', path)
      return {} unless status.success?

      lines = stdout.split('\n')
      return {} if lines.size < 2

      parts = lines[1].split
      return {} if parts.size < 4

      { available_bytes: parts[3].to_i }
    rescue StandardError
      {}
    end

    def resolve_device
      devices = block_devices
      raise Error, 'No block devices detected via lsblk.' if devices.empty?

      if options[:device]
        normalized = normalize_device_argument(options[:device])
        device = find_device(devices, normalized)
        raise Error, "Device #{normalized} not found." unless device

        describe_device(device)
        confirm_device_selection(device)
        return device
      end

      candidates = devices.select(&:probable_usb?)
      device =
        if candidates.empty?
          puts 'No removable USB devices detected automatically. Showing all disks:'
          prompt_for_device(devices)
        else
          puts 'Select the USB device to overwrite:'
          prompt_for_device(candidates)
        end

      describe_device(device)
      confirm_device_selection(device)
      device
    end

    def describe_device(device)
      puts "\nSelected device: #{device.description}"
      partitions = device.partitions
      return if partitions.empty?

      puts 'Existing partitions:'
      partitions.each do |part|
        mount_info = part.mountpoints.empty? ? '' : " (mounted at #{part.mountpoints.join(', ')})"
        fs = part.filesystem.to_s.empty? ? 'unknown-fs' : part.filesystem
        puts format('  ‚Ä¢ %-10s %-10s %s%s', part.path, part.size.to_s, fs, mount_info)
      end
    end

    def confirm_device_selection(device)
      input = read_input("Type the device path (#{device.path}) to confirm selection: ")
      raise Error, 'Device confirmation failed.' unless input == device.path
    end

    def ensure_not_system_disk(device)
      return if options[:force]

      if system_disk?(device)
        raise Error, "#{device.path} appears to host system or encrypted partitions. Use --force if you are absolutely sure."
      end
    end

    def system_disk?(device)
      device_mounts = device.mountpoints
      return true if (device_mounts & CRITICAL_MOUNTPOINTS).any?

      device.partitions.any? do |part|
        mounts = part.mountpoints
        fs = part.filesystem.to_s.downcase
        (mounts & CRITICAL_MOUNTPOINTS).any? || SENSITIVE_FILESYSTEMS.include?(fs)
      end
    end

    def final_confirmation(device, iso)
      puts "\nAbout to write #{iso[:filename]} (#{human_size(File.size(iso[:path]))}) to #{device.path}."
      puts 'This will irreversibly destroy all data on the selected device.'
      input = read_input("Type WRITE #{device.path} to continue: ")
      raise Error, 'Final confirmation failed.' unless input == "WRITE #{device.path}"
    end

    def human_size(bytes)
      units = %w[B KiB MiB GiB TiB]
      idx = 0
      value = bytes.to_f
      while value >= 1024 && idx < units.length - 1
        value /= 1024
        idx += 1
      end
      format('%.2f %s', value, units[idx])
    end

    def ensure_device_unmounted(device)
      device = reload_device(device)
      busy = device.partitions.select(&:mounted?)
      return if busy.empty?

      puts '\nThe following partitions are mounted:'
      busy.each do |part|
        puts format('  ‚Ä¢ %-10s -> %s', part.path, part.mountpoints.join(', '))
      end

      answer = read_input('Unmount them automatically? [y/N]: ').to_s.strip.downcase
      raise Error, 'Abort: partitions remain mounted.' unless %w[y yes].include?(answer)

      busy.each do |part|
        run_privileged!(%W[umount #{part.path}])
      end

      run_privileged!(%w[udevadm settle]) if which('udevadm')
    end

    def capture_device_signature(device)
      stat = File.stat(device.path)
      { rdev: stat.rdev, serial: device.serial, size: device.size }
    rescue Errno::ENOENT
      raise Error, "Device #{device.path} disappeared."
    end

    def ensure_signature_unchanged!(device)
      latest = capture_device_signature(device)
      return if latest == @device_signature

      raise Error, 'Device signature changed after selection. Aborting to avoid wrong-disk overwrite.'
    end

    def discover_sha_files
      # Fetch directory listing using curl
      curl = which('curl')
      if curl
        stdout, status = Open3.capture2(curl, '-sL', '--connect-timeout', CONNECT_TIMEOUT.to_s, '--max-time', DOWNLOAD_TIMEOUT.to_s, DOWNLOAD_BASE)
        raise Error, "Failed to fetch directory listing (exit #{status.exitstatus})" unless status.success?
        listing_body = stdout
      else
        # Fallback to Net::HTTP
        uri = URI(DOWNLOAD_BASE)
        response = Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == 'https',
                                    open_timeout: CONNECT_TIMEOUT, read_timeout: DOWNLOAD_TIMEOUT) do |http|
          request = Net::HTTP::Get.new(uri)
          http.request(request)
        end
        raise Error, "Failed to fetch directory listing: #{response.code}" unless response.is_a?(Net::HTTPSuccess)
        listing_body = response.body
      end

      # Extract SHA256SUMS-YYYY.MM filenames
      versions = listing_body.scan(/SHA256SUMS-(\d{4}\.\d{2})/).flatten.uniq.sort
      raise Error, 'No SHA256SUMS files found in directory listing.' if versions.empty?

      versions
    end

    def fetch_latest_iso
      # Discover available SHA256SUMS files
      sha_files = discover_sha_files
      raise Error, 'No SHA256SUMS files found on server.' if sha_files.empty?

      # Use the latest version
      latest_sha_file = sha_files.max
      sha_filename = "SHA256SUMS-#{latest_sha_file}"
      sig_filename = "#{sha_filename}.gpg"

      sha_path = File.join(@tmpdir, sha_filename)
      sig_path = File.join(@tmpdir, sig_filename)

      download_to(URI.join(DOWNLOAD_BASE, sha_filename), sha_path, label: sha_filename)
      download_to(URI.join(DOWNLOAD_BASE, sig_filename), sig_path, label: sig_filename)
      verify_signature(sha_path, sig_path)
      entries = parse_sha_entries(File.read(sha_path))
      raise Error, "No entries found for variant #{options[:variant]} with arch #{options[:arch]}" if entries.empty?

      entry = entries.max_by { |e| e[:version_key] }
      entry.merge(path: nil)
    end

    def download_iso(metadata)
      destination = File.join(@tmpdir, metadata[:filename])
      download_to(metadata[:url], destination, label: metadata[:filename])
      metadata[:path] = destination
      destination
    end

    def import_grml_key
      gpg = which('gpg')
      raise Error, 'gpg is required to import signing keys.' unless gpg

      puts '\nImporting Grml signing key...'
      key_filename = File.basename(URI(GRML_KEY_URL).path)
      key_path = File.join(@tmpdir, key_filename)
      download_to(URI(GRML_KEY_URL), key_path, label: key_filename)
      run_system!([gpg, '--import', key_path])
    end

    def verify_signature(sha_path, sig_path)
      gpg = which('gpg')
      raise Error, 'gpg is required for signature verification.' unless gpg

      cmd = [gpg, '--verify', sig_path, sha_path]
      run_system!(cmd)
    rescue Error => e
      hint = options[:import_grml_key] ? '' : ' Use --import-grml-key to download the official key automatically.'
      raise Error, "GPG verification failed: #{e.message}. Import the Grml signing keys first.#{hint}"
    end

    def parse_sha_entries(body)
      # New format: grml-full-2025.08-amd64.iso
      variant = options[:variant]
      arch = options[:arch]
      pattern_prefix = "#{variant}-"
      pattern_suffix = "-#{arch}.iso"

      body.each_line.filter_map do |line|
        next unless line =~ /^([0-9a-f]{64})\s+(.+)$/

        sha = Regexp.last_match(1)
        file = File.basename(Regexp.last_match(2))
        next unless file.start_with?(pattern_prefix)
        next unless file.end_with?(pattern_suffix)

        # Extract version from grml-full-2025.08-amd64.iso -> 2025.08
        version = file.delete_prefix(pattern_prefix).delete_suffix(pattern_suffix)
        { filename: file, sha256: sha, version_key: version_key(version), url: URI.join(DOWNLOAD_BASE, file) }
      end
    end

    def version_key(version)
      if (match = version.match(/^(\d{4})\.(\d{2})(.*)$/))
        [match[1].to_i, match[2].to_i, match[3]]
      else
        [0, 0, version]
      end
    end

    def download_to(url, destination, label: File.basename(destination))
      puts "\nDownloading #{label}..."
      temp_path = "#{destination}.part"
      FileUtils.mkdir_p(File.dirname(destination))
      existing_bytes = File.exist?(temp_path) ? File.size(temp_path) : 0
      if (curl = which('curl'))
        cmd = [
          curl, '-fL',
          '--connect-timeout', CONNECT_TIMEOUT.to_s,
          '--max-time', DOWNLOAD_TIMEOUT.to_s,
          '-C', '-',
          '-o', temp_path,
          url.to_s
        ]
        run_system!(cmd, stream: true)
      else
        http_download_to(url, temp_path, resume_from: existing_bytes)
      end

      FileUtils.rm_f(destination)
      FileUtils.mv(temp_path, destination)
    end

    def http_download_to(url, destination, resume_from: 0)
      uri = url.is_a?(URI) ? url : URI(url.to_s)
      Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == 'https') do |http|
        http.open_timeout = CONNECT_TIMEOUT
        http.read_timeout = DOWNLOAD_TIMEOUT
        request = Net::HTTP::Get.new(uri)
        request['Range'] = "bytes=#{resume_from}-" if resume_from.positive?
        http.request(request) do |response|
          case response
          when Net::HTTPPartialContent
            mode = resume_from.positive? ? 'ab' : 'wb'
          when Net::HTTPSuccess
            mode = 'wb'
          when Net::HTTPRequestedRangeNotSatisfiable
            FileUtils.rm_f(destination)
            return http_download_to(uri, destination, resume_from: 0)
          else
            raise Error, "Download failed: #{response.code} #{response.message}"
          end

          File.open(destination, mode) do |file|
            response.read_body { |chunk| file.write(chunk) }
          end
        end
      end
    end

    def verify_checksum(path, expected)
      print "\nVerifying SHA256 checksum... "
      actual = Digest::SHA256.file(path).hexdigest
      raise Error, "Checksum mismatch: expected #{expected}, got #{actual}." unless actual == expected

      puts 'OK'
    end

    def customize_iso(iso_path, metadata)
      puts "\nüìù Customizing ISO with boot parameters..."

      xorriso = which('xorriso')
      raise Error, 'xorriso is required to customize ISO. Install with: sudo pacman -S libisoburn' unless xorriso

      extract_dir = File.join(@tmpdir, 'iso-extract')
      FileUtils.mkdir_p(extract_dir)

      # Extract ISO
      puts "Extracting ISO..."
      cmd = [xorriso, '-osirrox', 'on', '-indev', iso_path, '-extract', '/', extract_dir]
      run_system!(cmd)

      # Make extracted files writable
      run_system!(['chmod', '-R', 'u+w', extract_dir])

      # Create WiFi enable script if requested
      if options[:enable_wifi]
        create_wifi_enable_script(extract_dir)
      end

      # Find and modify grub configs
      grub_configs = Dir.glob(File.join(extract_dir, 'boot/grub/*_default.cfg')) +
                     Dir.glob(File.join(extract_dir, 'boot/grub/*_options.cfg'))

      if grub_configs.empty?
        warn "Warning: No grub config files found to modify"
      else
        puts "Modifying #{grub_configs.size} config file(s)..."
        grub_configs.each do |config_path|
          content = File.read(config_path)
          modified = false

          content.gsub!(/^(\s*linux\s+\S+\s+)(.+)$/) do
            prefix = Regexp.last_match(1)
            params = Regexp.last_match(2)
            modified = true
            "#{prefix}#{params} #{options[:boot_params]}"
          end

          if modified
            File.write(config_path, content)
            puts "  Modified: #{File.basename(config_path)}"
          end
        end
      end


      # Create new ISO
      custom_iso = File.join(@tmpdir, "custom-#{metadata[:filename]}")
      puts "Creating customized ISO..."

      # Use xorriso to create bootable ISO
      cmd = [
        xorriso,
        '-as', 'mkisofs',
        '-o', custom_iso,
        '-isohybrid-mbr', '/usr/lib/syslinux/bios/isohdpfx.bin',
        '-c', 'boot/isolinux/boot.cat',
        '-b', 'boot/isolinux/isolinux.bin',
        '-no-emul-boot',
        '-boot-load-size', '4',
        '-boot-info-table',
        '-eltorito-alt-boot',
        '-e', 'boot/efi.img',
        '-no-emul-boot',
        '-isohybrid-gpt-basdat',
        '-V', 'GRML',
        extract_dir
      ]
      run_system!(cmd, stream: true)

      puts "‚úÖ Custom ISO created"
      custom_iso
    end

    def create_wifi_enable_script(extract_dir)
      puts "Adding WiFi auto-enable script..."

      # Create scripts directory
      scripts_dir = File.join(extract_dir, 'boot/grub/scripts')
      FileUtils.mkdir_p(scripts_dir)

      # Create WiFi enable script
      wifi_script = File.join(scripts_dir, 'wifi-enable')
      script_content = <<~'SCRIPT'
        #!/bin/sh
        # Auto-enable WiFi on boot
        if command -v rfkill >/dev/null 2>&1; then
          rfkill unblock all
        fi

        # Find and bring up wireless interfaces
        for iface in /sys/class/net/wl*; do
          if [ -e "$iface" ]; then
            ifname=$(basename "$iface")
            ip link set "$ifname" up 2>/dev/null || true
          fi
        done
      SCRIPT

      File.write(wifi_script, script_content)
      File.chmod(0o755, wifi_script)
      puts "  Added WiFi auto-enable script"
    end

    def flash_image(image_path, device)
      ensure_signature_unchanged!(device)
      puts "\nWriting image to #{device.path}..."
      dd_cmd = ['dd', "if=#{image_path}", "of=#{device.path}"] + DD_ARGS
      run_privileged!(dd_cmd, stream: true)
      run_privileged!(%w[sync], stream: true)
      if (partprobe = which('partprobe'))
        run_privileged!([partprobe, device.path])
      end
    end

    def verify_written_image(image_path, device)
      cmp = which('cmp')
      raise Error, 'cmp (from coreutils) is required for verification.' unless cmp

      puts '\nVerifying written data matches source image...'
      bytes = File.size(image_path)
      cmd = [cmp, "--bytes=#{bytes}", image_path, device.path]
      run_privileged!(cmd, stream: true)
    rescue Error => e
      raise Error, "Post-write verification failed: #{e.message}"
    end

    def block_devices
      columns = %w[NAME PATH RM HOTPLUG TRAN SIZE MODEL SERIAL VENDOR TYPE FSTYPE LABEL MOUNTPOINT MOUNTPOINTS]
      json = capture_json(['lsblk', '-J', '-o', columns.join(',')])
      data = JSON.parse(json)
      Array(data['blockdevices']).map { |entry| BlockDevice.new(entry) }.select(&:disk?)
    end

    def capture_json(cmd)
      stdout, status = Open3.capture2(*cmd)
      raise Error, "Command failed (exit #{status.exitstatus}): #{cmd.join(' ')}" unless status.success?

      stdout
    end

    def find_device(devices, path)
      devices.find { |device| device.path == path }
    end

    def reload_device(device)
      refreshed = find_device(block_devices, device.path)
      raise Error, "Device #{device.path} disappeared." unless refreshed

      refreshed
    end

    def prompt_for_device(devices)
      devices.each_with_index do |device, index|
        puts format('%2d) %-15s %-10s %s', index + 1, device.path, device.size, device.model)
      end
      choice = read_input("Select device [1-#{devices.size}]: ")
      idx = Integer(choice)
      raise Error, 'Selection out of range.' unless idx.between?(1, devices.size)

      devices[idx - 1]
    rescue ArgumentError
      raise Error, 'Invalid selection.'
    end

    def normalize_device_argument(arg)
      path = arg.start_with?('/dev/') ? arg : "/dev/#{arg}"
      raise Error, "#{path} is not a block device." unless File.blockdev?(path)

      path
    end

    def read_input(prompt)
      print prompt
      $stdout.flush
      input = $stdin.gets
      raise Error, 'No input received.' if input.nil?

      input.strip
    end

    def download_client
      which('curl')
    end

    def which(name)
      ENV.fetch('PATH', '').split(File::PATH_SEPARATOR).each do |dir|
        candidate = File.join(dir, name)
        return candidate if File.executable?(candidate) && !File.directory?(candidate)
      end
      nil
    end

    def run_privileged!(cmd, stream: false)
      run_system!(wrap_if_needed(cmd), stream: stream)
    end

    def wrap_if_needed(cmd)
      return cmd if !@use_sudo

      ['sudo', '--'] + cmd
    end

    def run_system!(cmd, stream: false)
      if stream
        @child_pid = spawn(*cmd)
        _, status = Process.wait2(@child_pid)
        @child_pid = nil
        raise Error, "Command failed (exit #{status.exitstatus}): #{cmd.join(' ')}" unless status.success?
      else
        stdout, status = Open3.capture2e(*cmd)
        raise Error, "Command failed (exit #{status.exitstatus}): #{cmd.join(' ')}\n#{stdout}" unless status.success?
      end
    ensure
      @child_pid = nil if stream
    end

    def cleanup_tmpdir
      FileUtils.remove_entry(@tmpdir) if @tmpdir && Dir.exist?(@tmpdir)
    rescue StandardError
      # ignore cleanup failures
    end
  end
end

options = {
  variant: LiveUsb::Creator::DEFAULT_VARIANT,
  arch: LiveUsb::Creator::DEFAULT_ARCH,
  import_grml_key: false
}

parser = OptionParser.new do |opts|
  opts.banner = 'Usage: create-grml-live-usb [options]'
  opts.on('-d', '--device PATH', 'Explicit block device path (e.g., /dev/sdx)') do |path|
    options[:device] = path
  end
  opts.on('-v', '--variant NAME', 'Grml variant (default: grml-full)') do |variant|
    LiveUsb::Creator.validate_variant!(variant)
    # Map old variant names to new ones for backward compatibility
    variant = 'grml-full' if variant == 'grml64-full'
    variant = 'grml-small' if variant == 'grml64-small'
    options[:variant] = variant
  end
  opts.on('-a', '--arch ARCH', 'Architecture: amd64 or arm64 (default: amd64)') do |arch|
    raise LiveUsb::Error, 'Architecture must be amd64 or arm64' unless %w[amd64 arm64].include?(arch)
    options[:arch] = arch
  end
  opts.on('--force', 'Override system disk detection.') do
    options[:force] = true
  end
  opts.on('--import-grml-key', 'Download and import the official Grml signing key before verification.') do
    options[:import_grml_key] = true
  end
  opts.on('--boot-params PARAMS', 'Custom boot parameters to add (e.g., "lang=fr fbcon=font:TER16x32")') do |params|
    options[:boot_params] = params
  end
  opts.on('--ssh [PASSWORD]', 'Enable SSH with optional password (default: grml). Username is "grml".') do |password|
    options[:enable_ssh] = true
    options[:ssh_password] = password || 'grml'
  end
  opts.on('--wifi', 'Auto-enable WiFi (rfkill unblock and bring interface up)') do
    options[:enable_wifi] = true
  end
  opts.on('-h', '--help', 'Show this help message') do
    puts opts
    puts "\nExamples:"
    puts "  # Create USB with 4K display + French keyboard + SSH access"
    puts "  #{File.basename($PROGRAM_NAME)} -d /dev/sda \\"
    puts "    --boot-params \"lang=fr fbcon=font:TER16x32\" \\"
    puts "    --ssh grml \\"
    puts "    --import-grml-key"
    puts ""
    puts "  # USB with SSH using custom password"
    puts "  #{File.basename($PROGRAM_NAME)} -d /dev/sda --ssh mypassword --import-grml-key"
    puts ""
    puts "  # Standard USB without customization"
    puts "  #{File.basename($PROGRAM_NAME)} -d /dev/sda --import-grml-key"
    puts ""
    puts "Security Note:"
    puts "  SSH with simple passwords is convenient but less secure."
    puts "  For production use, consider SSH keys instead."
    exit 0
  end
end

parser.parse!(ARGV)

LiveUsb::Creator.new(options).run
