#!/bin/sh
# A robust wrapper for i3status to add the hostname and project code.

# Start i3status and pipe its output for processing
i3status | (
    # Read and print the first two lines (header and opening bracket)
    read -r line && echo "$line"
    read -r line && echo "$line"

    # Source project codes within subshell so variables are available here
    PROJECTS_FILE="$HOME/.projects"
    if [ -f "$PROJECTS_FILE" ]; then
        # shellcheck disable=SC1090
        . "$PROJECTS_FILE"
    fi

    # Process each JSON array from i3status in a loop
    while read -r line; do
        # The line from i3status is a JSON array, sometimes with a leading comma.
        # Store the comma and remove it for processing.
        if echo "$line" | grep -q '^,'; then
            line_to_process=$(echo "$line" | cut -c 2-)
            leading_comma=","
        else
            line_to_process=$line
            leading_comma=""
        fi

        # Determine active project code
        if [ -f /tmp/project_secondary_on ]; then
            proj_code="${SECONDARY_PROJECT_CODE}"
        else
            proj_code="${PRIMARY_PROJECT_CODE}"
        fi
        [ -n "$proj_code" ] || proj_code="PRJ"

        # Prepare injected segments: hostname and project code
        with_hostname=$(echo "$line_to_process" | jq --arg host "$(hostnamectl hostname)" '[{ "full_text": $host, "name": "hostname" }] + .')
        with_project=$(echo "$with_hostname" | jq --arg proj "$proj_code" '[{ "full_text": $proj, "name": "project" }] + .')

        # Add a red CAPS indicator when Caps Lock is active.
        caps_state=$(xset -q 2>/dev/null | awk '/Caps Lock:/ {print $4; exit}' | tr '[:upper:]' '[:lower:]')
        with_caps="$with_project"
        if [ "${caps_state:-off}" = "on" ]; then
            with_caps=$(echo "$with_project" | jq --arg text "CAPS" --arg color "#FF3B30" '[{ "full_text": $text, "name": "caps_lock", "color": $color }] + .')
        fi

        # Calculate RAM usage and color (inserted before disk block later).
        mem_text=""
        mem_color=""
        mem_kb=$(awk '/MemTotal:/ {total=$2} /MemAvailable:/ {avail=$2} END {if (total > 0) printf "%d %d", total, avail}' /proc/meminfo)
        if [ -n "$mem_kb" ]; then
            set -- $mem_kb
            total_kb=$1
            avail_kb=$2
            used_kb=$((total_kb - avail_kb))
            mem_pct=$(((used_kb * 100 + total_kb / 2) / total_kb))
            mem_text="RAM ${mem_pct}%"

            if [ "$mem_pct" -gt 90 ]; then
                mem_color="#FF0000"
            elif [ "$mem_pct" -gt 80 ]; then
                mem_color="#FFA500"
            fi
        fi

        # Determine current keyboard layout from setxkbmap and format for display.
        layout=$(setxkbmap -query | awk '/layout:/ {print $2}' | cut -d',' -f1)
        [ -n "$layout" ] || layout="??"
        layout_display=$(printf '%s' "$layout" | tr '[:lower:]' '[:upper:]')
        with_layout=$(echo "$with_caps" | jq --arg layout "$layout_display" '[{ "full_text": $layout, "name": "keyboard_layout" }] + .')

        # Check if running kernel matches latest installed kernel package
        running_kernel=$(uname -r)
        installed_kernel=$(pacman -Q linux 2>/dev/null | awk '{print $2}' | sed 's/\.arch/-arch/')
        with_reboot="$with_layout"
        if [ -n "$installed_kernel" ] && [ "$running_kernel" != "$installed_kernel" ]; then
            with_reboot=$(echo "$with_layout" | jq --arg text "REBOOT" --arg color "#FFA500" '[{ "full_text": $text, "name": "kernel_mismatch", "color": $color }] + .')
        fi

        # Insert RAM usage right before root disk usage.
        with_ram="$with_reboot"
        if [ -n "$mem_text" ]; then
            ram_block=$(jq -n --arg text "$mem_text" --arg color "$mem_color" 'if $color == "" then {"full_text": $text, "name": "ram_usage"} else {"full_text": $text, "name": "ram_usage", "color": $color} end')
            with_ram=$(echo "$with_reboot" | jq --argjson ram "$ram_block" 'if any(.[]; .name == "disk_info" and .instance == "/") then reduce .[] as $item ([]; if $item.name == "disk_info" and $item.instance == "/" then . + [$ram, $item] else . + [$item] end) else . + [$ram] end')
        fi

        # Check for disk health alerts
        with_disk="$with_ram"
        if [ -f /tmp/disk-health-alert ]; then
            alert_level=$(cat /tmp/disk-health-alert 2>/dev/null | head -1)
            if [ "$alert_level" = "ERROR" ]; then
                with_disk=$(echo "$with_ram" | jq --arg text "DISK!" --arg color "#FF0000" '[{ "full_text": $text, "name": "disk_alert", "color": $color }] + .')
            elif [ "$alert_level" = "WARN" ]; then
                with_disk=$(echo "$with_ram" | jq --arg text "DISK" --arg color "#FFA500" '[{ "full_text": $text, "name": "disk_warning", "color": $color }] + .')
            fi
        fi

        # Print the re-assembled line with the leading comma
        echo "$leading_comma$with_disk"
    done
)

# vim: ft=sh ts=4 sw=4 et
